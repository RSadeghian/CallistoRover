/*
 * pid.cpp
 *
 *  Created on: Mar 25, 2017
 *      Author: karan
 */

#include "pid.h"

pid::pid(float PGain, float IGain, float DGain, float cmd_max , float cmd_min, float vel_max, float vel_min)
: Kp(PGain),Ki(IGain),Kd(DGain),motorCmdMax(cmd_max),motorCmdMin(cmd_min),motorMaxAngularVel(vel_max)
,motorMinAngularVel(vel_min)
{
	prevError = 0;
	intError = 0;
	diffError = 0;
	cmd = 0;
}

pid::~pid()
{
	// TODO Auto-generated destructor stub
}

void pid::Update(float currValue, float refValue)
{
	float error;

	error = refValue - currValue;
	intError += error;

	diffError = error - prevError;
	cmd = Kp*error + Kd*diffError + Ki*intError;
	cmd += refValue;
	cmd = velToCmd(cmd);
	prevError = error;
}

float pid::velToCmd(float angularVelTarget)
{
	//saturate the output cmd generated by update

	    float motorCmd;

	    float slope = (motorCmdMax - motorCmdMin)/(motorMaxAngularVel - motorMinAngularVel);

	    //deadzone for the motor commands
	    float intercept = 20;

	    if (angularVelTarget ==0)
	        return 0;

	    if (angularVelTarget > 0)
	    {

	        motorCmd = slope*(angularVelTarget) + intercept;
	        if(motorCmd> motorCmdMax)
	        	motorCmd = motorCmdMax;
	        if(motorCmd < motorCmdMin)
	        	motorCmd = motorCmdMin;
	    }
	    else
	    {
	    	motorCmd = slope*(angularVelTarget) + intercept;
	        if(motorCmd > motorCmdMax)
	        	motorCmd = motorCmdMax;
	        if(motorCmd < motorCmdMin)
	        	motorCmd = motorCmdMin;

	    }

	    return motorCmd;
}

float pid::getCmd()
{
	return cmd;
}


float pid::getError()
{
    return prevError;
}

float pid::setGains(float PGain, float IGain, float DGain)
{
	Kp = PGain;
	Ki = IGain;
	Kd = DGain;
}
